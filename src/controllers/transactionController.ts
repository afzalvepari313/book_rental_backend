import { Request, Response } from 'express';
import { Transaction } from '../models/transactionModel';
import { User } from '../models/userModel';
import { Book } from '../models/bookModel';

export const issueBook = async (req: Request, res: Response) => {
  const { bookName, userId, issueDate } = req.body;

  if (!bookName || !userId || !issueDate) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  try {
    // Validate user
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Check if the book is already issued
    const existingTransaction = await Transaction.findOne({ bookName, returnDate: { $exists: false } });
    if (existingTransaction) {
      return res.status(400).json({ error: 'Book is already issued' });
    }

    // Create a new transaction
    const transaction = new Transaction({ bookName, userId, issueDate });
    await transaction.save();

    res.status(201).json({ message: 'Transaction created successfully', transaction });
  } catch (error) {
    console.error('Error issuing book:', error);
    res.status(500).json({ error: 'An error occurred while issuing the book' });
  }
};

export const returnBook = async (req: Request, res: Response) => {
  const { bookName, userId, returnDate } = req.body;

  if (!bookName || !userId || !returnDate) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  try {
    const transaction = await Transaction.findOne({ bookName, userId, returnDate: { $exists: false } });
    if (transaction) {
      transaction.returnDate = returnDate;

      const daysRented = Math.ceil((new Date(returnDate).getTime() - new Date(transaction.issueDate).getTime()) / (1000 * 3600 * 24));
      const book = await Book.findOne({ name: bookName });
      const totalRent = daysRented * (book?.rentPerDay || 0);
      transaction.rent= totalRent;

      await transaction.save();

      res.status(200).json({ message: 'Transaction updated successfully', totalRent });
    } else {
      res.status(404).json({ error: 'Transaction not found' });
    }
  } catch (error) {
    console.error('Error returning book:', error);
    res.status(500).json({ error: 'An error occurred while returning the book' });
  }
};

// Get List of People Who Issued a Book
export const getBookDetails = async (req: Request, res: Response) => {
  const { bookName } = req.params;

  try {
    const transactions = await Transaction.find({ bookName });

    const currentlyIssued = transactions.find(t => !t.returnDate);

    res.status(200).json({
      totalCount: transactions.length,
      currentlyIssued: currentlyIssued ? {
        userId: currentlyIssued.userId,
        username: (await User.findById(currentlyIssued.userId))?.name
      } : { status: 'Not Issued' }
    });
  } catch (error) {
    console.error('Error retrieving book details:', error);
    res.status(500).json({ error: 'An error occurred while retrieving book details' });
  }
};

// Get Total Rent Generated by a Book
export const getTotalRent = async (req: Request, res: Response) => {
  const { bookName } = req.params;

  try {
    const transactions = await Transaction.find({ bookName, rent: { $ne: null } });

    // Type guard to ensure `rent` is defined
    const totalRent = transactions.reduce((sum, t) => {
      if (t.rent !== undefined) {
        return sum + t.rent;
      }
      return sum;
    }, 0);

    res.status(200).json({ totalRent });
  } catch (error) {
    console.error('Error calculating total rent:', error);
    res.status(500).json({ error: 'An error occurred while calculating total rent' });
  }
};

// Get List of Books Issued to a Person
export const getUserBooks = async (req: Request, res: Response) => {
  const { userId } = req.params;

  try {
    const transactions = await Transaction.find({ userId });

    res.status(200).json({ booksIssued: transactions.map(t => ({
      bookName: t.bookName,
      issueDate: t.issueDate,
      returnDate: t.returnDate
    })) });
  } catch (error) {
    console.error('Error retrieving user books:', error);
    res.status(500).json({ error: 'An error occurred while retrieving user books' });
  }
};

// Get List of Books Issued in a Date Range
// export const getBooksByDateRange = async (req: Request, res: Response) => {
//   const { startDate, endDate } = req.query;

//   if (!startDate || !endDate) {
//     return res.status(400).json({ error: 'Missing required query parameters' });
//   }

//   try {
//     const transactions = await Transaction.find({
//       issueDate: { $gte: new Date(startDate), $lte: new Date(endDate) }
//     });

//     res.status(200).json({ booksIssued: transactions.map(t => ({
//       bookName: t.bookName,
//       userId: t.userId,
//       issueDate: t.issueDate,
//       returnDate: t.returnDate
//     })) });
//   } catch (error) {
//     console.error('Error retrieving books by date range:', error);
//     res.status(500).json({ error: 'An error occurred while retrieving books by date range' });
//   }
// };

export const getBooksByDateRange = async (req: Request, res: Response) => {
  // Extract and validate query parameters
  const { startDate, endDate } = req.query;

  // Check if startDate and endDate are provided and are strings
  if (typeof startDate !== 'string' || typeof endDate !== 'string') {
    return res.status(400).json({ error: 'Invalid query parameters' });
  }
  try {
    const start = new Date(startDate);
    const end = new Date(endDate);
    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
      return res.status(400).json({ error: 'Invalid date format' });
    }
    const transactions = await Transaction.find({
      issueDate: { $gte: start, $lte: end }
    });
    res.status(200).json({
      booksIssued: transactions.map(t => ({
        bookName: t.bookName,
        userId: t.userId,
        issueDate: t.issueDate,
        returnDate: t.returnDate
      }))
    });
  } catch (error) {
    console.error('Error retrieving books by date range:', error);
    res.status(500).json({ error: 'An error occurred while retrieving books by date range' });
  }
};
  
export const getTransactionHistory = async (req: Request, res: Response) => {
  const { bookName } = req.query;
  const transactions = await Transaction.find({ bookName }).populate('userId').populate('bookId');
  res.status(200).json(transactions);
};
